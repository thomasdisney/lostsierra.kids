<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Slipbot Simulator V2</title>
    <style>
      :root {
        color-scheme: dark;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        background: #0c1118;
        color: #f5f6fa;
        font-family: "Segoe UI", Roboto, sans-serif;
        overflow: hidden;
      }
      header {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        height: 64px;
        background: rgba(10, 16, 24, 0.9);
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 0 24px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        backdrop-filter: blur(8px);
        z-index: 10;
      }
      header h1 {
        margin: 0;
        font-size: 18px;
        letter-spacing: 1px;
        text-transform: uppercase;
      }
      header .controls {
        display: flex;
        gap: 12px;
      }
      button {
        background: #1f8ef1;
        border: none;
        color: white;
        padding: 10px 18px;
        border-radius: 6px;
        font-size: 14px;
        cursor: pointer;
        transition: transform 0.15s ease, box-shadow 0.15s ease;
      }
      button:active {
        transform: scale(0.96);
      }
      button.secondary {
        background: #3a3f4a;
      }
      canvas {
        position: fixed;
        top: 64px;
        left: 0;
        width: 100vw;
        height: calc(100vh - 64px);
      }
      .hud {
        position: fixed;
        bottom: 12px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(12, 17, 24, 0.85);
        padding: 10px 16px;
        border-radius: 20px;
        font-size: 13px;
        display: flex;
        gap: 16px;
        align-items: center;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.25);
        pointer-events: none;
      }
      @media (max-width: 768px) {
        header {
          flex-direction: column;
          align-items: flex-start;
          height: auto;
          padding: 16px;
          gap: 12px;
        }
        canvas {
          top: 112px;
          height: calc(100vh - 112px);
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h1>Slipbot Simulator V2</h1>
      <div class="controls">
        <button id="randomizeBtn" class="secondary">Randomize Layout</button>
        <button id="resetBtn" class="secondary">Reset View</button>
        <button id="exitBtn">Exit</button>
      </div>
    </header>
    <canvas id="simCanvas"></canvas>
    <div class="hud" id="hud"></div>
    <script>
      (() => {
        const canvas = document.getElementById("simCanvas");
        const ctx = canvas.getContext("2d");
        const hud = document.getElementById("hud");
        const header = document.querySelector("header");

        const speedControl = { value: 130 }; // pixels per second (debugging aid)

        const world = {
          slipbots: [],
          trailers: [],
          parkingSpots: [],
          attachments: new Map(),
          exitEngaged: false,
          exitTargets: [],
          gridSize: 72,
        };

        const colors = {
          slipbotBody: "#26deff",
          slipbotAttached: "#45d483",
          trailerBody: "#7f8fa6",
          trailerOutline: "#c8d6e5",
          parkingSpot: "rgba(69, 212, 131, 0.25)",
          parkingOutline: "rgba(69, 212, 131, 0.65)",
          text: "#dfe6e9",
        };

        const dragState = {
          active: false,
          type: null,
          item: null,
          parkingIndex: null,
          pointerId: null,
          offsetX: 0,
          offsetY: 0,
          rotationMode: false,
          initialAngle: 0,
          initialPointerAngle: 0,
        };

        let lastTimestamp = performance.now();

        function resizeCanvas() {
          const dpr = window.devicePixelRatio || 1;
          const width = window.innerWidth;
          const height = window.innerHeight - header.offsetHeight;
          canvas.width = width * dpr;
          canvas.height = height * dpr;
          canvas.style.width = width + "px";
          canvas.style.height = height + "px";
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
          world.exitTargets = generateExitTargets();
        }

        function createSlipbot(id, x, y) {
          return {
            id,
            x,
            y,
            radius: 22,
            color: colors.slipbotBody,
            isDragging: false,
            attachedTrailerId: null,
            attachedSpotIndex: null,
            attachmentOffset: { x: 0, y: 0 },
            angle: 0,
            targetAngle: 0,
            path: [],
            planning: false,
            goal: null,
            speed: speedControl.value,
            replanCooldown: 0,
          };
        }

        function createTrailer(id, x, y, angle = 0) {
          const width = 160;
          const height = 60;
          const parkingOffsets = [
            { x: -48, y: 0, angle: 0 },
            { x: 0, y: 0, angle: 0 },
            { x: 48, y: 0, angle: 0 },
          ];
          return {
            id,
            x,
            y,
            width,
            height,
            angle,
            parkingOffsets,
            isDragging: false,
          };
        }

        function createParkingSpot(id, x, y, angle = 0) {
          return {
            id,
            x,
            y,
            radius: 24,
            angle,
            isDragging: false,
          };
        }

        function resetWorld() {
          world.slipbots = [
            createSlipbot("S1", 180, 200),
            createSlipbot("S2", 340, 220),
            createSlipbot("S3", 280, 340),
            createSlipbot("S4", 420, 360),
          ];
          world.trailers = [
            createTrailer("T1", 650, 260, 0.05),
            createTrailer("T2", 900, 420, -0.15),
          ];
          world.parkingSpots = [
            createParkingSpot("P1", 260, 520, 0),
            createParkingSpot("P2", 520, 520, 0),
            createParkingSpot("P3", 780, 520, 0),
          ];
          world.exitEngaged = false;
          world.exitTargets = generateExitTargets();
          detachAll();
        }

        function randomizeWorld() {
          const width = canvas.width / (window.devicePixelRatio || 1);
          const height = canvas.height / (window.devicePixelRatio || 1);
          world.slipbots.forEach((bot, idx) => {
            bot.x = 120 + Math.random() * (width - 240);
            bot.y = 140 + Math.random() * (height - 200);
            bot.angle = Math.random() * Math.PI * 2;
            bot.path = [];
            bot.goal = null;
            bot.attachedTrailerId = null;
            bot.attachedSpotIndex = null;
          });
          world.trailers.forEach((trailer) => {
            trailer.x = 220 + Math.random() * (width - 440);
            trailer.y = 200 + Math.random() * (height - 300);
            trailer.angle = (Math.random() - 0.5) * 0.6;
          });
          world.parkingSpots.forEach((spot) => {
            spot.x = 180 + Math.random() * (width - 360);
            spot.y = height - 160 + Math.random() * 80;
            spot.angle = 0;
          });
          detachAll();
        }

        function detachAll() {
          world.slipbots.forEach((bot) => {
            bot.attachedTrailerId = null;
            bot.attachedSpotIndex = null;
            bot.attachmentOffset = { x: 0, y: 0 };
            bot.color = colors.slipbotBody;
            bot.path = [];
            bot.goal = null;
          });
        }

        function getTrailerSpotWorld(trailer, index) {
          const offset = trailer.parkingOffsets[index];
          if (!offset) return null;
          const cos = Math.cos(trailer.angle);
          const sin = Math.sin(trailer.angle);
          const x = trailer.x + offset.x * cos - offset.y * sin;
          const y = trailer.y + offset.x * sin + offset.y * cos;
          const angle = trailer.angle + offset.angle;
          return { x, y, angle };
        }

        function attachSlipbotToTrailer(bot, trailer, index) {
          bot.attachedTrailerId = trailer.id;
          bot.attachedSpotIndex = index;
          bot.color = colors.slipbotAttached;
          bot.goal = null;
          bot.path = [];
          const spot = getTrailerSpotWorld(trailer, index);
          bot.x = spot.x;
          bot.y = spot.y;
          bot.angle = spot.angle;
        }

        function detachSlipbot(bot) {
          bot.attachedTrailerId = null;
          bot.attachedSpotIndex = null;
          bot.color = colors.slipbotBody;
        }

        function generateExitTargets() {
          const width = canvas.width / (window.devicePixelRatio || 1);
          const height = canvas.height / (window.devicePixelRatio || 1);
          const margin = 120;
          const spacing = 80;
          return world.slipbots.map((_, index) => ({
            x: width - margin,
            y: margin + index * spacing,
          }));
        }

        function pointerToCanvas(e) {
          const rect = canvas.getBoundingClientRect();
          return {
            x: (e.clientX - rect.left),
            y: (e.clientY - rect.top),
          };
        }

        function hitTestSlipbot(x, y) {
          for (let i = world.slipbots.length - 1; i >= 0; i -= 1) {
            const bot = world.slipbots[i];
            const dx = x - bot.x;
            const dy = y - bot.y;
            if (Math.hypot(dx, dy) <= bot.radius + 6) {
              return bot;
            }
          }
          return null;
        }

        function hitTestTrailer(x, y) {
          for (let i = world.trailers.length - 1; i >= 0; i -= 1) {
            const trailer = world.trailers[i];
            const cos = Math.cos(-trailer.angle);
            const sin = Math.sin(-trailer.angle);
            const relX = cos * (x - trailer.x) - sin * (y - trailer.y);
            const relY = sin * (x - trailer.x) + cos * (y - trailer.y);
            if (
              relX >= -trailer.width / 2 &&
              relX <= trailer.width / 2 &&
              relY >= -trailer.height / 2 &&
              relY <= trailer.height / 2
            ) {
              return trailer;
            }
          }
          return null;
        }

        function hitTestParkingSpot(x, y) {
          for (let i = world.parkingSpots.length - 1; i >= 0; i -= 1) {
            const spot = world.parkingSpots[i];
            const dx = x - spot.x;
            const dy = y - spot.y;
            if (Math.hypot(dx, dy) <= spot.radius + 8) {
              return spot;
            }
          }
          return null;
        }

        function onPointerDown(e) {
          const point = pointerToCanvas(e);
          const trailer = hitTestTrailer(point.x, point.y);
          const slipbot = hitTestSlipbot(point.x, point.y);
          const parking = hitTestParkingSpot(point.x, point.y);

          if (trailer && e.button === 2) {
            dragState.active = true;
            dragState.type = "trailer";
            dragState.item = trailer;
            dragState.pointerId = e.pointerId;
            dragState.rotationMode = true;
            dragState.initialAngle = trailer.angle;
            dragState.initialPointerAngle = Math.atan2(point.y - trailer.y, point.x - trailer.x);
            canvas.setPointerCapture(e.pointerId);
            return;
          }

          if (slipbot && e.button === 0) {
            dragState.active = true;
            dragState.type = "slipbot";
            dragState.item = slipbot;
            dragState.pointerId = e.pointerId;
            dragState.offsetX = point.x - slipbot.x;
            dragState.offsetY = point.y - slipbot.y;
            if (slipbot.attachedTrailerId) {
              detachSlipbot(slipbot);
            }
            canvas.setPointerCapture(e.pointerId);
            return;
          }

          if (trailer && e.button === 0) {
            dragState.active = true;
            dragState.type = "trailer";
            dragState.item = trailer;
            dragState.pointerId = e.pointerId;
            dragState.offsetX = point.x - trailer.x;
            dragState.offsetY = point.y - trailer.y;
            dragState.rotationMode = false;
            canvas.setPointerCapture(e.pointerId);
            return;
          }

          if (parking && e.button === 0) {
            dragState.active = true;
            dragState.type = "parking";
            dragState.item = parking;
            dragState.pointerId = e.pointerId;
            dragState.offsetX = point.x - parking.x;
            dragState.offsetY = point.y - parking.y;
            canvas.setPointerCapture(e.pointerId);
            return;
          }
        }

        function onPointerMove(e) {
          if (!dragState.active || dragState.pointerId !== e.pointerId) return;
          const point = pointerToCanvas(e);

          if (dragState.type === "slipbot") {
            const bot = dragState.item;
            bot.x = point.x - dragState.offsetX;
            bot.y = point.y - dragState.offsetY;
            bot.path = [];
            bot.goal = null;
            world.exitEngaged = false;
            return;
          }

          if (dragState.type === "trailer") {
            const trailer = dragState.item;
            if (dragState.rotationMode) {
              const angle = Math.atan2(point.y - trailer.y, point.x - trailer.x);
              const delta = angle - dragState.initialPointerAngle;
              trailer.angle = dragState.initialAngle + delta;
            } else {
              trailer.x = point.x - dragState.offsetX;
              trailer.y = point.y - dragState.offsetY;
            }
            world.exitEngaged = false;
            return;
          }

          if (dragState.type === "parking") {
            const spot = dragState.item;
            spot.x = point.x - dragState.offsetX;
            spot.y = point.y - dragState.offsetY;
            world.exitEngaged = false;
          }
        }

        function onPointerUp(e) {
          if (dragState.active && dragState.pointerId === e.pointerId) {
            dragState.active = false;
            dragState.item = null;
            dragState.pointerId = null;
            dragState.type = null;
            dragState.rotationMode = false;
            canvas.releasePointerCapture(e.pointerId);
          }
        }

        function registerPointerEvents() {
          canvas.addEventListener("pointerdown", onPointerDown);
          canvas.addEventListener("pointermove", onPointerMove);
          canvas.addEventListener("pointerup", onPointerUp);
          canvas.addEventListener("pointercancel", onPointerUp);
          canvas.addEventListener("contextmenu", (e) => e.preventDefault());
        }

        function updateAttachments() {
          world.slipbots.forEach((bot) => {
            if (!bot.attachedTrailerId) return;
            const trailer = world.trailers.find((t) => t.id === bot.attachedTrailerId);
            if (!trailer) {
              detachSlipbot(bot);
              return;
            }
            const spot = getTrailerSpotWorld(trailer, bot.attachedSpotIndex);
            if (!spot) {
              detachSlipbot(bot);
              return;
            }
            bot.x = spot.x;
            bot.y = spot.y;
            bot.angle = spot.angle;
          });
        }

        function resolveTrailerDocking() {
          world.slipbots.forEach((bot) => {
            if (bot.attachedTrailerId) return;
            for (const trailer of world.trailers) {
              for (let i = 0; i < trailer.parkingOffsets.length; i += 1) {
                const spot = getTrailerSpotWorld(trailer, i);
                if (!spot) continue;
                const occupied = world.slipbots.some(
                  (other) =>
                    other !== bot &&
                    other.attachedTrailerId === trailer.id &&
                    other.attachedSpotIndex === i
                );
                if (occupied) continue;
                const distance = Math.hypot(bot.x - spot.x, bot.y - spot.y);
                if (distance <= bot.radius + 6) {
                  attachSlipbotToTrailer(bot, trailer, i);
                  return;
                }
              }
            }
          });
        }

        function computeOccupancyGrid(excludeBot) {
          const cellSize = world.gridSize;
          const width = canvas.width / (window.devicePixelRatio || 1);
          const height = canvas.height / (window.devicePixelRatio || 1);
          const cols = Math.ceil(width / cellSize);
          const rows = Math.ceil(height / cellSize);
          const grid = new Array(rows);
          for (let y = 0; y < rows; y += 1) {
            grid[y] = new Array(cols).fill(0);
          }
          const inflate = 34;
          const markCircle = (cx, cy, radius) => {
            const minCol = Math.max(0, Math.floor((cx - radius) / cellSize));
            const maxCol = Math.min(cols - 1, Math.floor((cx + radius) / cellSize));
            const minRow = Math.max(0, Math.floor((cy - radius) / cellSize));
            const maxRow = Math.min(rows - 1, Math.floor((cy + radius) / cellSize));
            for (let row = minRow; row <= maxRow; row += 1) {
              for (let col = minCol; col <= maxCol; col += 1) {
                const cellCenterX = col * cellSize + cellSize / 2;
                const cellCenterY = row * cellSize + cellSize / 2;
                if (Math.hypot(cellCenterX - cx, cellCenterY - cy) <= radius) {
                  grid[row][col] = 1;
                }
              }
            }
          };

          const markRect = (cx, cy, widthRect, heightRect, angle = 0) => {
            const cos = Math.cos(-angle);
            const sin = Math.sin(-angle);
            const minCol = Math.max(0, Math.floor((cx - widthRect) / cellSize));
            const maxCol = Math.min(cols - 1, Math.floor((cx + widthRect) / cellSize));
            const minRow = Math.max(0, Math.floor((cy - heightRect) / cellSize));
            const maxRow = Math.min(rows - 1, Math.floor((cy + heightRect) / cellSize));
            for (let row = minRow; row <= maxRow; row += 1) {
              for (let col = minCol; col <= maxCol; col += 1) {
                const worldX = col * cellSize + cellSize / 2;
                const worldY = row * cellSize + cellSize / 2;
                const relX = cos * (worldX - cx) - sin * (worldY - cy);
                const relY = sin * (worldX - cx) + cos * (worldY - cy);
                if (
                  Math.abs(relX) <= widthRect / 2 + inflate &&
                  Math.abs(relY) <= heightRect / 2 + inflate
                ) {
                  grid[row][col] = 1;
                }
              }
            }
          };

          world.trailers.forEach((trailer) => {
            markRect(trailer.x, trailer.y, trailer.width + inflate * 2, trailer.height + inflate * 2, trailer.angle);
          });

          world.parkingSpots.forEach((spot) => {
            markCircle(spot.x, spot.y, spot.radius + inflate);
          });

          world.slipbots.forEach((bot) => {
            if (bot === excludeBot) return;
            markCircle(bot.x, bot.y, bot.radius + inflate * 0.6);
          });

          return { grid, cellSize, cols, rows };
        }

        function heuristic(a, b) {
          return Math.hypot(a.x - b.x, a.y - b.y);
        }

        function neighbors(node, cols, rows) {
          const dirs = [
            [1, 0],
            [-1, 0],
            [0, 1],
            [0, -1],
            [1, 1],
            [1, -1],
            [-1, 1],
            [-1, -1],
          ];
          const result = [];
          for (const [dx, dy] of dirs) {
            const nx = node.col + dx;
            const ny = node.row + dy;
            if (nx >= 0 && nx < cols && ny >= 0 && ny < rows) {
              result.push({ col: nx, row: ny });
            }
          }
          return result;
        }

        function planPath(bot, goal) {
          const { grid, cellSize, cols, rows } = computeOccupancyGrid(bot);
          const startCol = Math.min(cols - 1, Math.max(0, Math.floor(bot.x / cellSize)));
          const startRow = Math.min(rows - 1, Math.max(0, Math.floor(bot.y / cellSize)));
          const goalCol = Math.min(cols - 1, Math.max(0, Math.floor(goal.x / cellSize)));
          const goalRow = Math.min(rows - 1, Math.max(0, Math.floor(goal.y / cellSize)));

          const startKey = `${startCol},${startRow}`;
          const goalKey = `${goalCol},${goalRow}`;

          const openSet = new Map();
          const cameFrom = new Map();
          const gScore = new Map();
          const fScore = new Map();
          const priorityQueue = [];

          function push(nodeKey, node) {
            priorityQueue.push({ key: nodeKey, ...node });
            priorityQueue.sort((a, b) => a.f - b.f);
          }

          function pop() {
            return priorityQueue.shift();
          }

          const startNode = { col: startCol, row: startRow };
          openSet.set(startKey, startNode);
          gScore.set(startKey, 0);
          fScore.set(startKey, heuristic({ x: startCol, y: startRow }, { x: goalCol, y: goalRow }));
          push(startKey, { col: startCol, row: startRow, f: fScore.get(startKey) });

          const visitedLimit = 4000;
          let visited = 0;

          while (priorityQueue.length && visited < visitedLimit) {
            visited += 1;
            const current = pop();
            if (!current) break;
            const currentKey = current.key;
            if (currentKey === goalKey) {
              return reconstructPath(cameFrom, currentKey, goalKey, cellSize, goal);
            }
            const { col, row } = current;
            openSet.delete(currentKey);
            const neigh = neighbors({ col, row }, cols, rows);
            for (const next of neigh) {
              const key = `${next.col},${next.row}`;
              if (grid[next.row][next.col] === 1) continue;
              const tentativeG = gScore.get(currentKey) + Math.hypot(next.col - col, next.row - row);
              if (tentativeG < (gScore.get(key) ?? Infinity)) {
                cameFrom.set(key, currentKey);
                gScore.set(key, tentativeG);
                const f = tentativeG + heuristic({ x: next.col, y: next.row }, { x: goalCol, y: goalRow });
                fScore.set(key, f);
                if (!openSet.has(key)) {
                  openSet.set(key, next);
                  push(key, { col: next.col, row: next.row, f });
                }
              }
            }
          }
          return [];
        }

        function reconstructPath(cameFrom, currentKey, goalKey, cellSize, goal) {
          const path = [];
          let key = currentKey;
          while (cameFrom.has(key)) {
            const [col, row] = key.split(",").map(Number);
            path.push({ x: col * cellSize + cellSize / 2, y: row * cellSize + cellSize / 2 });
            key = cameFrom.get(key);
          }
          const [startCol, startRow] = key.split(",").map(Number);
          path.push({ x: startCol * cellSize + cellSize / 2, y: startRow * cellSize + cellSize / 2 });
          path.reverse();
          path.push({ x: goal.x, y: goal.y });
          return smoothPath(path);
        }

        function smoothPath(path) {
          if (path.length <= 2) return path;
          const smoothed = [path[0]];
          for (let i = 1; i < path.length - 1; i += 1) {
            const prev = smoothed[smoothed.length - 1];
            const curr = path[i];
            const next = path[i + 1];
            const anglePrev = Math.atan2(curr.y - prev.y, curr.x - prev.x);
            const angleNext = Math.atan2(next.y - curr.y, next.x - curr.x);
            const delta = Math.abs(angleNext - anglePrev);
            if (delta > Math.PI / 3) {
              smoothed.push(curr);
            }
          }
          smoothed.push(path[path.length - 1]);
          return smoothed;
        }

        function updateSlipbotMovement(bot, dt) {
          if (bot.attachedTrailerId) return;
          if (!bot.path.length) return;

          if (!bot.goal) {
            bot.path = [];
            return;
          }

          const nextPoint = bot.path[0];
          const dx = nextPoint.x - bot.x;
          const dy = nextPoint.y - bot.y;
          const distance = Math.hypot(dx, dy);

          if (distance < 4) {
            bot.x = nextPoint.x;
            bot.y = nextPoint.y;
            bot.path.shift();
            if (!bot.path.length) {
              bot.angle = bot.goal.angle ?? bot.angle;
              return;
            }
            return;
          }

          const direction = Math.atan2(dy, dx);
          const moveDistance = Math.min(distance, bot.speed * dt);
          bot.x += Math.cos(direction) * moveDistance;
          bot.y += Math.sin(direction) * moveDistance;

          const angleDiff = normalizeAngle(direction - bot.angle);
          const maxTurn = dt * 2.4;
          if (Math.abs(angleDiff) > 0.01) {
            bot.angle += clamp(angleDiff, -maxTurn, maxTurn);
          }
        }

        function normalizeAngle(angle) {
          while (angle > Math.PI) angle -= Math.PI * 2;
          while (angle < -Math.PI) angle += Math.PI * 2;
          return angle;
        }

        function clamp(value, min, max) {
          return Math.max(min, Math.min(max, value));
        }

        function updatePlanning(bot, dt) {
          if (bot.attachedTrailerId) return;
          if (!bot.goal) return;

          bot.replanCooldown -= dt;
          const needsPlan = !bot.path.length || bot.replanCooldown <= 0;
          if (!needsPlan) {
            const lookahead = bot.path[0];
            const blocking = world.trailers.some((trailer) => {
              const distance = pointToRotatedRectDistance(lookahead, trailer);
              return distance < bot.radius + 8;
            });
            if (!blocking) return;
          }

          bot.path = planPath(bot, bot.goal);
          bot.replanCooldown = 0.6 + Math.random() * 0.4;
        }

        function pointToRotatedRectDistance(point, trailer) {
          const cos = Math.cos(-trailer.angle);
          const sin = Math.sin(-trailer.angle);
          const relX = cos * (point.x - trailer.x) - sin * (point.y - trailer.y);
          const relY = sin * (point.x - trailer.x) + cos * (point.y - trailer.y);
          const dx = Math.max(Math.abs(relX) - trailer.width / 2, 0);
          const dy = Math.max(Math.abs(relY) - trailer.height / 2, 0);
          return Math.hypot(dx, dy);
        }

        function engageExit() {
          world.exitEngaged = true;
          world.exitTargets = generateExitTargets();
          world.slipbots.forEach((bot, index) => {
            if (bot.attachedTrailerId) return;
            const target = world.exitTargets[index % world.exitTargets.length];
            bot.goal = { x: target.x, y: target.y, angle: 0 };
            bot.path = planPath(bot, bot.goal);
            bot.replanCooldown = 0.3;
          });
        }

        function updateHud() {
          hud.textContent = `Slipbots: ${world.slipbots.length}  •  Trailers: ${world.trailers.length}  •  Speed: ${speedControl.value.toFixed(0)}px/s`;
        }

        function draw() {
          const width = canvas.width / (window.devicePixelRatio || 1);
          const height = canvas.height / (window.devicePixelRatio || 1);
          ctx.clearRect(0, 0, width, height);
          drawGrid(width, height);
          world.parkingSpots.forEach(drawParkingSpot);
          world.trailers.forEach(drawTrailer);
          world.slipbots.forEach(drawSlipbot);
        }

        function drawGrid(width, height) {
          const cellSize = world.gridSize;
          ctx.save();
          ctx.strokeStyle = "rgba(255,255,255,0.05)";
          ctx.lineWidth = 1;
          for (let x = 0; x <= width; x += cellSize) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, height);
            ctx.stroke();
          }
          for (let y = 0; y <= height; y += cellSize) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(width, y);
            ctx.stroke();
          }
          ctx.restore();
        }

        function drawParkingSpot(spot) {
          ctx.save();
          ctx.translate(spot.x, spot.y);
          ctx.rotate(spot.angle);
          ctx.fillStyle = colors.parkingSpot;
          ctx.strokeStyle = colors.parkingOutline;
          ctx.beginPath();
          ctx.arc(0, 0, spot.radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.lineWidth = 2;
          ctx.stroke();
          ctx.restore();
        }

        function drawTrailer(trailer) {
          ctx.save();
          ctx.translate(trailer.x, trailer.y);
          ctx.rotate(trailer.angle);
          ctx.fillStyle = colors.trailerBody;
          ctx.strokeStyle = colors.trailerOutline;
          ctx.lineWidth = 3;
          const w = trailer.width;
          const h = trailer.height;
          const r = 14;
          ctx.beginPath();
          ctx.moveTo(-w / 2 + r, -h / 2);
          ctx.lineTo(w / 2 - r, -h / 2);
          ctx.quadraticCurveTo(w / 2, -h / 2, w / 2, -h / 2 + r);
          ctx.lineTo(w / 2, h / 2 - r);
          ctx.quadraticCurveTo(w / 2, h / 2, w / 2 - r, h / 2);
          ctx.lineTo(-w / 2 + r, h / 2);
          ctx.quadraticCurveTo(-w / 2, h / 2, -w / 2, h / 2 - r);
          ctx.lineTo(-w / 2, -h / 2 + r);
          ctx.quadraticCurveTo(-w / 2, -h / 2, -w / 2 + r, -h / 2);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();

          trailer.parkingOffsets.forEach((offset, index) => {
            const radius = 24;
            ctx.save();
            ctx.translate(offset.x, offset.y);
            ctx.fillStyle = "rgba(0,0,0,0.25)";
            ctx.strokeStyle = "rgba(0,0,0,0.45)";
            ctx.beginPath();
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.fillStyle = "rgba(255,255,255,0.25)";
            ctx.font = "12px Segoe UI";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(`${index + 1}`, 0, 0);
            ctx.restore();
          });
          ctx.restore();
        }

        function drawSlipbot(bot) {
          ctx.save();
          ctx.translate(bot.x, bot.y);
          ctx.rotate(bot.angle);
          ctx.fillStyle = bot.color;
          ctx.beginPath();
          ctx.arc(0, 0, bot.radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = "rgba(255,255,255,0.35)";
          ctx.lineWidth = 2;
          ctx.stroke();

          ctx.strokeStyle = "rgba(12, 17, 24, 0.8)";
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(bot.radius, 0);
          ctx.stroke();

          ctx.fillStyle = colors.text;
          ctx.font = "12px Segoe UI";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(bot.id, 0, -bot.radius - 12);
          ctx.restore();

          if (bot.path.length > 0) {
            ctx.save();
            ctx.strokeStyle = "rgba(38, 222, 255, 0.35)";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(bot.x, bot.y);
            bot.path.forEach((point) => {
              ctx.lineTo(point.x, point.y);
            });
            ctx.stroke();
            ctx.restore();
          }
        }

        function update(delta) {
          resolveTrailerDocking();
          updateAttachments();
          world.slipbots.forEach((bot) => {
            updatePlanning(bot, delta);
            updateSlipbotMovement(bot, delta);
          });
        }

        function loop(timestamp) {
          const delta = Math.min((timestamp - lastTimestamp) / 1000, 0.1);
          lastTimestamp = timestamp;
          update(delta);
          draw();
          updateHud();
          requestAnimationFrame(loop);
        }

        function setupControls() {
          document.getElementById("exitBtn").addEventListener("click", engageExit);
          document.getElementById("resetBtn").addEventListener("click", () => {
            resetWorld();
          });
          document.getElementById("randomizeBtn").addEventListener("click", () => {
            randomizeWorld();
          });
          window.addEventListener("keydown", (e) => {
            if (e.key === "-") {
              speedControl.value = Math.max(40, speedControl.value - 10);
              world.slipbots.forEach((bot) => (bot.speed = speedControl.value));
            }
            if (e.key === "=") {
              speedControl.value = Math.min(280, speedControl.value + 10);
              world.slipbots.forEach((bot) => (bot.speed = speedControl.value));
            }
          });
        }

        window.addEventListener("resize", resizeCanvas);
        registerPointerEvents();
        setupControls();
        resizeCanvas();
        resetWorld();
        requestAnimationFrame((time) => {
          lastTimestamp = time;
          loop(time);
        });
      })();
    </script>
  </body>
</html>
